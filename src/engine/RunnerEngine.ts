import type { EngineInput } from "./contracts/EngineInput.js";
import type { RiskLevel } from "./contracts/RiskLevel.js";
import type { DecisionTraceV2 } from "./contracts/trace/DecisionTraceV2.js";

import crypto from "crypto";

import { ExecutionLedger } from "../runtime/ledger/ExecutionLedger.js";
import { SystemClock } from "./runtime/Clock.js";
import type { Clock } from "./runtime/Clock.js";

import { MultiFrameworkOrchestrator } from "./orchestrator/MultiFrameworkOrchestrator.js";
import { AIGovFramework } from "./frameworks/AIGovFramework.js";
import { NISTFramework } from "./frameworks/NISTFramework.js";

import { FindingNormalizer } from "./adapters/FindingNormalizer.js";

import { DomainRiskAggregationEngine } from "./scoring/DomainRiskAggregationEngine.js";
import { OverallRiskAggregationEngine } from "./scoring/OverallRiskAggregationEngine.js";

import { DomainRiskAggregationEngineV2 } from "./scoring/v2/DomainRiskAggregationEngineV2.js";
import { OverallRiskAggregationEngineV2 } from "./scoring/v2/OverallRiskAggregationEngineV2.js";

import { ReportBuilder } from "../reporting/ReportBuilder.js";
import { ReportExporter } from "../reporting/ReportExporter.js";

import { DEFAULT_ENGINE_MODE, type EngineMode } from "./EngineMode.js";

type Decision = {
  severity: RiskLevel;
  drivers: string[];
  trace?: DecisionTraceV2;
};

const mapRiskLevelToTraceSeverity = (sev: string): "Low" | "Medium" | "High" | "Critical" => {
  if (sev === "Moderate") return "Medium";
  if (sev === "Low" || sev === "Medium" || sev === "High" || sev === "Critical") {
    return sev;
  }
  return "Medium";
};

export class RunnerEngine {
  private ledger = new ExecutionLedger();
  private clock: Clock;
  private mode: EngineMode;

  constructor(
    clock: Clock = new SystemClock(),
    mode: EngineMode = DEFAULT_ENGINE_MODE
  ) {
    this.clock = clock;
    this.mode = mode;
  }

  async run(input: EngineInput) {
    const orchestrator = new MultiFrameworkOrchestrator([
      new AIGovFramework(),
      new NISTFramework()
    ]);

    const frameworkResults = await orchestrator.runAll(input, this.clock);

    const rawFindings = frameworkResults.flatMap(r => r.findings);
    const allFindings = FindingNormalizer.normalize(rawFindings);

    let decision: Decision;

    if (this.mode === "V2") {
      const domainProfilesV2 = DomainRiskAggregationEngineV2.aggregate(
        allFindings,
        input.context
      );

      const overallV2 = OverallRiskAggregationEngineV2.aggregate(domainProfilesV2);

      // Flatten driversByDomain -> string[]
      const flattenedDrivers = Object.values(overallV2.driversByDomain).flat();

      const traceV2: DecisionTraceV2 = {
  version: "2.0",

  meta: {
    engineVersion: "0.3.2",
    generatedAt: new Date().toISOString(),
    inputHash: crypto.createHash("sha256").update(JSON.stringify(input)).digest("hex"),
    traceId: crypto.randomUUID()
  },

  decision: {
    outcome: overallV2.severity === "Low" ? "ALLOW" : overallV2.severity === "Moderate" ? "REVIEW" : "DENY",
    severity: mapRiskLevelToTraceSeverity(overallV2.severity),
    confidence: 0.5
  },

  scores: {
    inherentRisk: overallV2.score,
    residualRisk: overallV2.score,
    controlEffectiveness: 1,
    finalScore: overallV2.score
  },

  drivers: flattenedDrivers.map(label => ({
    id: label,
    label,
    weight: 1,
    delta: 0,
    direction: "UP"
  })),

  evaluations: [],

  severityDerivation: {
    fromScore: overallV2.score,
    toSeverity: mapRiskLevelToTraceSeverity(overallV2.severity),
    rule: "OverallRiskAggregationEngineV2"
  },

  reasoning: {
    summary: "Decision generated by SecureLogic Engine V2",
    bulletPoints: flattenedDrivers
  }
};

      decision = process.env.SECURELOGIC_EXPLAIN
        ? {
            severity: overallV2.severity,
            drivers: flattenedDrivers,
            trace: traceV2
          }
        : {
            severity: overallV2.severity,
            drivers: flattenedDrivers
          };
    } else {
      const domainProfilesV1 = DomainRiskAggregationEngine.aggregate(
        allFindings,
        input.context
      );

      const overallV1 = OverallRiskAggregationEngine.aggregate(domainProfilesV1);

      decision = {
        severity: overallV1.severity,
        drivers: overallV1.drivers
      };
    }

    const ledgerHash = this.ledger.append(input, {
      decision,
      frameworks: frameworkResults.map(f => f.framework)
    });

    const report = ReportBuilder.build(
      input.client,
      input,
      decision,
      ledgerHash,
      allFindings
    );

    ReportExporter.exportToJson(report);

    return { decision, report };
  }

  verifyLedger() {
    return this.ledger.verify();
  }
}